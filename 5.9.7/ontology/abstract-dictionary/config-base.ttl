@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix v-wf: <http://semantic-machines.com/veda/veda-workflow/> .
@prefix v-s: <http://semantic-machines.com/veda/veda-schema/> .
@prefix v-ui: <http://semantic-machines.com/veda/veda-ui/> .
@prefix cfg: <http://semantic-machines.com/veda/config/> .
@prefix td: <http://semantic-machines.com/veda/test-data/> .

@prefix cfgb: <http://semantic-machines.com/veda/config-base/> .
<http://semantic-machines.com/veda/config-base>
  rdf:type owl:Ontology ;
  rdfs:label "Онтология Веда. Обработчики событий"@ru ;
  rdfs:label "Veda ontology. Event handlers"@en ;
#  owl:versionInfo "1.0" ;
  v-s:loadPriority 3;
.

cfg:Event_0
  rdf:type v-s:Event1 ;
  v-s:runAt "V8.LowPriority" ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "test event";
  rdfs:comment "test event";
  v-s:script """
var res = query (ticket, "'rdf:type' == 'v-s:Event'");
log_trace("res=", res);
  """ ;
.

cfg:Event_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  v-s:preventByType v-s:Version;
  v-s:preventByType v-s:Group;
  v-s:preventByType v-s:Connection;
  v-s:preventByType v-s:Credential;
  v-s:preventByType v-s:Event;
  v-s:preventByType v-s:Account;
  v-s:preventByType v-s:Person;
  v-s:preventByType v-s:Position;
  v-s:preventByType v-s:Appointment;
  v-s:preventByType v-s:Department;
  v-s:preventByType v-s:Organization;
  v-s:preventByType v-s:OrgGroup;
  v-s:preventByType v-s:OrganizationUnit;
  rdfs:label "Скрипт помещает все индивиды в группу cfg:TTLResourcesGroup" ;
  rdfs:comment "Скрипт помещает все индивиды в группу cfg:TTLResourcesGroup" ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */
// First class event
if (parent_script_id) return;

const doc_uri = document['@'];
const isDefinedBy = document['rdfs:isDefinedBy'];
if ( !isDefinedBy ) return;
const uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + 'cfg_TTLResourcesGroup';
const membership = {
  '@': uri,
  'rdf:type': veda.Util.newUri('v-s:Membership'),
  'v-s:memberOf': veda.Util.newUri('cfg:TTLResourcesGroup'),
  'v-s:resource': veda.Util.newUri(doc_uri),
  'rdfs:comment': veda.Util.newStr('создано автоматически в обработчике cfg:Event_1'),
};
put_individual(ticket, membership, _event_id);
  """ ;
.

cfg:Event_2
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт выдает права авторам (v-s:author), владельцам (v-s:owner), издателям (v-s:publisher) и создателям (v-s:creator)";
  rdfs:comment "Скрипт выдает права авторам (v-s:author), владельцам (v-s:owner), издателям (v-s:publisher) и создателям (v-s:creator)";
  v-s:preventByType v-s:Version;
  v-s:preventByType v-s:Account;
  v-s:preventByType v-s:Personal;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) return;

const doc_uri = document['@'];
const owner_properties = ['v-s:owner', 'v-s:author', 'v-s:publisher', 'v-s:creator'];

owner_properties.map(function (property_uri) {
  if (document[property_uri]) {
    document[property_uri].map(function (value) {
      const owner_uri = value.data;
      if (owner_uri && owner_uri !== 'cfg:VedaSystem') {
        const owner = get_individual(ticket, owner_uri);
        if (owner) {
          const owner_type = veda.Util.getUri(owner['rdf:type']);
          if (owner_type === 'v-s:Person' || owner_type === 'v-s:Position') {
            const permission_uri = 'd:right_' + doc_uri.split(':').join('_') + '_' + owner_uri.split(':').join('_') + '_event2';
            addPermission(permission_uri, owner_uri, doc_uri, ['v-s:canRead', 'v-s:canUpdate', 'v-s:canDelete']);
          } else if (owner_type === 'v-s:Appointment') {
            const position_uri = veda.Util.getUri(owner['v-s:occupation']);
            if (position_uri) {
              const permission_uri = 'd:right_' + doc_uri.split(':').join('_') + '_' + position_uri.split(':').join('_') + '_event2';
              addPermission(permission_uri, position_uri, doc_uri, ['v-s:canRead', 'v-s:canUpdate', 'v-s:canDelete']);
            }
            const person_uri = veda.Util.getUri(owner['v-s:employee']);
            if (person_uri) {
              const permission_uri = 'd:right_' + doc_uri.split(':').join('_') + '_' + person_uri.split(':').join('_') + '_event2';
              addPermission(permission_uri, person_uri, doc_uri, ['v-s:canRead', 'v-s:canUpdate', 'v-s:canDelete']);
            }
          }
        }
      }
    });
  }
});

function addPermission (permission_uri, subject_uri, object_uri, rights) {
  const permission = {
    '@': permission_uri,
    'rdf:type': veda.Util.newUri('v-s:PermissionStatement'),
    'v-s:permissionObject': veda.Util.newUri(object_uri),
    'v-s:permissionSubject': veda.Util.newUri(subject_uri),
  };
  rights.map(function (right) {
    permission[right] = veda.Util.newBool(true);
  });
  put_individual(ticket, permission);
}
  """ ;
.

cfg:Event_2_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт выдает права чтения персоне на аккаунт по полю v-s:owner";
  rdfs:comment "Скрипт выдает права чтения персоне на аккаунт по полю v-s:owner";
  v-s:preventByType v-s:Version;
  v-s:triggerByType v-s:Account;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) return;

if (!veda.Util.hasValue(document, 'v-s:owner')) return;
const account_uri = document['@'];
const person_uri = veda.Util.getUri(document['v-s:owner']);
const permission_uri = 'd:right_' + account_uri.split(':').join('_') + '_' + person_uri.split(':').join('_') + '_event_2_1';
const permission = {
  '@': permission_uri,
  'rdf:type': veda.Util.newUri('v-s:PermissionStatement'),
  'v-s:permissionSubject': veda.Util.newUri(person_uri),
  'v-s:permissionObject': veda.Util.newUri(account_uri),
  'v-s:canRead': veda.Util.newBool(true),
  'rdfs:comment' : veda.Util.newStr('создано автоматически в обработчике cfg:Event_2_1')
};
put_individual(ticket, permission);
  """ ;
.

cfg:Event_2_2
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт выдает права RUD персонам из автора (v-s:author), владельца (v-s:owner), издателя (v-s:publisher) и создателя (v-s:creator)";
  rdfs:comment "Клон event_2, но только для класса v-s:Personal и с выдачей прав только на персону";
  v-s:preventByType v-s:Version;
  v-s:triggerByType v-s:Personal;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
//if (parent_script_id) return;

const doc_uri = document['@'];
const owner_properties = ['v-s:owner', 'v-s:author', 'v-s:publisher', 'v-s:creator'];

owner_properties.map(function (property_uri) {
  if (document[property_uri]) {
    document[property_uri].map(function (value) {
      const owner_uri = value.data;
      if (owner_uri && owner_uri !== 'cfg:VedaSystem') {
        const owner = get_individual(ticket, owner_uri);
        if (owner) {
          const owner_type = veda.Util.getUri(owner['rdf:type']);
          if (owner_type === 'v-s:Person') {
            const permission_uri = 'd:right_' + doc_uri.split(':').join('_') + '_' + owner_uri.split(':').join('_') + '_event2_2';
            addPermission(permission_uri, owner_uri, doc_uri, ['v-s:canRead', 'v-s:canUpdate', 'v-s:canDelete']);
          } else if (owner_type === 'v-s:Appointment') {
            const person_uri = veda.Util.getUri(owner['v-s:employee']);
            if (person_uri) {
              const permission_uri = 'd:right_' + doc_uri.split(':').join('_') + '_' + person_uri.split(':').join('_') + '_event2';
              addPermission(permission_uri, person_uri, doc_uri, ['v-s:canRead', 'v-s:canUpdate', 'v-s:canDelete']);
            }
          }
        }
      }
    });
  }
});

function addPermission (permission_uri, subject_uri, object_uri, rights) {
  const permission = {
    '@': permission_uri,
    'rdf:type': veda.Util.newUri('v-s:PermissionStatement'),
    'v-s:permissionObject': veda.Util.newUri(object_uri),
    'v-s:permissionSubject': veda.Util.newUri(subject_uri),
  };
  rights.map(function (right) {
    permission[right] = veda.Util.newBool(true);
  });
  put_individual(ticket, permission);
}
  """ ;
.

cfg:Event_3
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт создает журнал документа" ;
  rdfs:comment "Скрипт создает журнал документа" ;
  v-s:preventByType v-s:Version;
  v-s:triggerByType v-s:Journaling, v-s:AutomaticallyVersioned ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) {
  // print("Not first class event. Exit.");
  return;
}

// Get latest document state
document = get_individual(ticket, document['@']);

var isAdmin = (user_uri === 'cfg:Administrator' || user_uri === 'cfg:VedaSystem');
var isJournaling = super_classes.indexOf('v-s:Journaling') >= 0 || veda.Util.hasValue(document, 'rdf:type', {data: 'v-s:Journaling', type: 'Uri'});
var isAutomaticallyVersioned = super_classes.indexOf('v-s:AutomaticallyVersioned') >= 0 || veda.Util.hasValue(document, 'rdf:type', {data: 'v-s:AutomaticallyVersioned', type: 'Uri'});

if (isAutomaticallyVersioned && !isAdmin && prev_state && !parent_script_id) {
  veda.Util.create_version(ticket, document, prev_state, user_uri, _event_id);
}

if (isJournaling) {
  var journal_uri = veda.Util.getJournalUri(document['@']);
  var exist_journal = get_individual(ticket, journal_uri);
  var user = get_individual(ticket, user_uri);
  var actor_uri = veda.Util.hasValue(user, 'v-s:defaultAppointment') ? veda.Util.getUri(user['v-s:defaultAppointment']) :
                  veda.Util.hasValue(user, 'v-s:hasAppointment') ? veda.Util.getUri(user['v-s:hasAppointment']) :
                  user_uri;

  if (exist_journal && isAdmin) { return; }

  if (exist_journal && !isAdmin) {
    // UPDATE DOCUMENT
    var journal_record = veda.Util.newJournalRecord(journal_uri);
    if ( document['v-s:actualVersion'] && document['v-s:actualVersion'][0].data === document['@'] ) {
      journal_record['v-s:documentVersion'] = document['v-s:previousVersion'];
    }
    var isDeleted = (!prev_state['v-s:deleted'] || prev_state['v-s:deleted'].data === false) && (document['v-s:deleted'] && document['v-s:deleted'].data === true);
    if (isDeleted) {
      journal_record['rdf:type'] = veda.Util.newUri('v-s:DocumentDeleted');
    } else {
      journal_record['rdf:type'] = veda.Util.newUri('v-s:DocumentUpdated');
    }
    journal_record['v-s:actor'] = veda.Util.newUri(actor_uri);
    veda.Util.logToJournal(ticket, journal_uri, journal_record);

  } else {
    // CREATE DOCUMENT
    var new_journal = {
      '@': journal_uri,
      'rdf:type': veda.Util.newUri('v-s:Journal'),
      'v-s:onDocument': veda.Util.newUri(document['@']),
      'v-s:actor': veda.Util.newUri(actor_uri),
    };
    put_individual(ticket, new_journal, _event_id);

    var journal_record = veda.Util.newJournalRecord(new_journal['@']);
    if (document['v-s:actualVersion'] && document['v-s:actualVersion'][0].data == document['@']) {
      journal_record['v-s:documentVersion'] = document['v-s:previousVersion'];
    }
    journal_record['rdf:type'] = veda.Util.newUri('v-s:DocumentCreated');
    journal_record['v-s:actor'] = veda.Util.newUri(actor_uri);
    veda.Util.logToJournal(ticket, journal_uri, journal_record);
  }
}
  """ ;
.

cfg:Event_4
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает персону в группу должности" ;
  rdfs:comment "Скрипт включает персону в группу должности при сохранении назначения. Если назначение удаляется, включение персоны в группу должности также удаляется." ;
  v-s:triggerByType v-s:Appointment ;
  v-s:preventByType v-s:Version ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

var doc_uri = document["@"],
    deleted = veda.Util.hasValue(document, "v-s:deleted", { data: true, type: "Boolean" }),
    person_uri = veda.Util.getUri(document["v-s:employee"]),
    position_uri = veda.Util.getUri(document["v-s:occupation"]);

if (!person_uri || !position_uri) return;

var membership_uri = "d:membership_" + doc_uri.split(":").join("_");
var old_membership_uri = "d:membership_" + person_uri.split(":").join("_") + "_" + position_uri.split(":").join("_");

if (deleted) {
  remove_individual(ticket, membership_uri);
  remove_individual(ticket, old_membership_uri);
} else {
  var membership = {
    "@" : membership_uri,
    "rdf:type"     : veda.Util.newUri("v-s:Membership"),
    "v-s:resource" : veda.Util.newUri(person_uri),
    "v-s:memberOf" : veda.Util.newUri(position_uri),
    "rdfs:comment" : veda.Util.newStr("создано автоматически в обработчике cfg:Event_4"),
  };
  if (veda.Util.getUri(document["v-s:hasDelegationPurpose"]) === "d:delegate_Control") {
    membership["v-s:canRead"] = veda.Util.newBool(true);
  }
  if ( veda.Util.hasValue(document, "v-s:official", {data: true, type: "Boolean"}) ) {
    membership["v-s:official"] = document["v-s:official"];
  }
  if ( veda.Util.hasValue(document, "v-s:ignoreExclusive", {data: true, type: "Boolean"}) ) {
    membership["v-s:ignoreExclusive"] = document["v-s:ignoreExclusive"];
  }
  put_individual (ticket, membership);
}
  """ ;
.

cfg:Event_5
  v-s:disabled true ;
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает персону (кроме cfg:Guest) в группу cfg:AllUsersGroup." ;
  rdfs:comment "Скрипт включает персону (кроме cfg:Guest) в группу cfg:AllUsersGroup." ;
  v-s:triggerByType v-s:Person ;
  v-s:preventByType v-s:Version;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) {
  // print("Not first class event. Exit.");
  return;
}

var doc_uri = document["@"],
    deleted = veda.Util.hasValue(document, "v-s:deleted", { data: true, type: "Boolean"}),
    uri = "d:membership_" + doc_uri.split(":").join("_") + "_" + "cfg_AllUsersGroup",
    membership;

if (doc_uri === "cfg:Guest") { return; }

// Manage accounts (delete or restore)
var accounts_uris = veda.Util.getUris(document["v-s:hasAccount"]);
accounts_uris.map(function (account_uri) {
  var account = get_individual(ticket, account_uri);
  if (account) {
    var account_deleted = veda.Util.hasValue(account, "v-s:deleted", { data: true, type: "Boolean"});
    if (deleted !== account_deleted) {
      account["v-s:deleted"] = veda.Util.newBool( deleted );
      put_individual (ticket, account, _event_id);
    }
  }
});

// Manage membership (delete or restore)
membership = get_individual(ticket, uri);

if (!membership) {
  membership = {
    "@" : uri,
    "rdf:type"     : veda.Util.newUri("v-s:Membership"),
    "v-s:resource" : veda.Util.newUri(doc_uri),
    "v-s:memberOf" : veda.Util.newUri("cfg:AllUsersGroup"),
    "rdfs:comment" : veda.Util.newStr("выдан cfg:Event_5"),
    "v-s:deleted"  : veda.Util.newBool( deleted )
  };
  put_individual (ticket, membership, _event_id);
  return;
}

var membership_deleted = veda.Util.hasValue(membership, "v-s:deleted", { data: true, type: "Boolean"});
if (deleted !== membership_deleted) {
  membership["v-s:deleted"] = veda.Util.newBool( deleted );
  put_individual (ticket, membership, _event_id);
}
  """ ;
.

cfg:Event_6
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает индивид онтологии и UI настроек в группу cfg:OntologyGroup." ;
  rdfs:comment "Скрипт включает индивид онтологии и UI настроек в группу cfg:OntologyGroup." ;
  v-s:triggerByType owl:Ontology ;
  v-s:triggerByType rdfs:Datatype ;
  v-s:triggerByType rdfs:Class ;
  v-s:triggerByType owl:Class ;
  v-s:triggerByType rdf:Property ;
  v-s:triggerByType owl:DatatypeProperty ;
  v-s:triggerByType owl:ObjectProperty ;
  v-s:triggerByType owl:OntologyProperty ;
  v-s:triggerByType owl:AnnotationProperty ;
  v-s:triggerByType v-ui:PropertySpecification ;
  v-s:triggerByType v-ui:DatatypePropertySpecification ;
  v-s:triggerByType v-ui:ObjectPropertySpecification ;
  v-s:triggerByType v-ui:ClassTemplate ;
  v-s:triggerByType v-ui:ClassModel ;
  v-s:triggerByType v-ui:TemplateSpecification ;
  v-s:triggerByType v-s:ClassSpecification ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) {
  // print("Not first class event. Exit.");
  return;
}

// Update ontology vsn
var vsn = {
  "@" : "cfg:OntoVsn",
  "rdf:type"  : veda.Util.newUri("rdfs:Resource"),
  "rdf:value" : veda.Util.newStr( veda.Util.guid() )
};
put_individual (ticket, vsn, _event_id);

// Add to cfg:OntologyGroup
var doc_uri = document['@'],
    uri = "d:membership_" + doc_uri.split(":").join("_") + "_cfg_OntologyGroup",
    membership = get_individual(ticket, uri);

if (membership) { return; }

membership = {
  '@' : uri,
  'rdf:type'     : veda.Util.newUri('v-s:Membership'),
  'v-s:memberOf' : veda.Util.newUri('cfg:OntologyGroup'),
  'v-s:resource' : veda.Util.newUri(doc_uri),
  'rdfs:comment' : veda.Util.newStr('выдан cfg:Event_6')
};
put_individual (ticket, membership, _event_id);
  """ ;
.

cfg:Event_9
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает вложенные индивиды в группу своего родителя." ;
  rdfs:comment "Скрипт включает вложенные индивиды в группу своего родителя." ;
  v-s:triggerByType v-s:Embedded ;
  v-s:preventByType v-s:Version;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
//if (parent_script_id) {
//  print("Not first class event. Exit.");
//  return;
//}

var doc_uri = document["@"],
  parent_uri = veda.Util.getUri( document["v-s:parent"] ),
  deleted = veda.Util.hasValue(document, "v-s:deleted", { data: true, type: "Boolean"});

if (!parent_uri) { return; }

var membership_uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + parent_uri.split(':').join('_');

if (deleted) {
  remove_individual(ticket, membership_uri, _event_id);
} else {
  var membership = {
    '@' : membership_uri,
    'rdf:type'     : veda.Util.newUri('v-s:Membership'),
    'v-s:memberOf' : veda.Util.newUri(parent_uri),
    'v-s:resource' : veda.Util.newUri(doc_uri),
    'rdfs:comment' : veda.Util.newStr('создано cfg:Event_9')
  };
  put_individual (ticket, membership, _event_id);
}

// Delete embedded tree
// 29.04.2021 - теперь должно происходить в эвенте cfg:Event_Document_Deleting_Restoring
// if (deleted) {
//   Object.keys(document).map(function (property_uri) {
//     if (property_uri === "@") { return; }
//     document[property_uri].map(function (value) {
//       if (value.type !== "Uri") { return; }
//       var embedded = get_individual(ticket, value.data);
//       if (embedded && veda.Util.hasValue(embedded, "v-s:parent", {data: doc_uri, type: "Uri"}) && !veda.Util.hasValue(embedded, "v-s:deleted", {data: true, type: "Boolean"}) ) {
//         embedded["v-s:deleted"] = veda.Util.newBool(true);
//         put_individual (ticket, embedded, _event_id);
//         //print("embedded deleted:", embedded["@"]);
//       }
//     });
//   });
// }
  """ ;
.

cfg:Event_10
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает журнал и записи журнала в группу документа с ограниченим прав до R." ;
  rdfs:comment "Скрипт включает журнал и записи журнала в группу документа с ограниченим прав до R." ;
  v-s:triggerByType v-s:Journal ;
  v-s:triggerByType v-s:JournalRecord ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */
if ( document['v-wf:isTrace'] || veda.Util.getUri(document['rdf:type']) === 'v-wf:TraceRecord' ) { return; }

var this_uri = document['@'],
    group_uri = veda.Util.getUri(document["v-s:onDocument"]) || veda.Util.getUri(document["v-s:parentJournal"]) || veda.Util.getUri(document["v-wf:onProcess"]);

if (!group_uri) { return; }

var membership_uri = 'd:membership_' + this_uri.split(':').join('_') + '_' + group_uri.split(':').join('_');

var membership = {
  '@' : membership_uri,
  'rdf:type'     : veda.Util.newUri('v-s:Membership'),
  'v-s:resource' : veda.Util.newUri(this_uri),
  'v-s:memberOf' : veda.Util.newUri(group_uri),
  'rdfs:comment' : veda.Util.newStr('создано cfg:Event_10'),
  'v-s:canRead'  : veda.Util.newBool(true)
};
put_individual (ticket, membership, _event_id);
//print('cfg:Event_10 journal membership', uri);
  """ ;
.

cfg:Event_11
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает задания в группу запущенного процесса с ограниченим прав до R." ;
  rdfs:comment "Скрипт включает задания в группу запущенного процесса с ограниченим прав до R." ;
  v-s:triggerByType v-wf:Process ;
  v-s:triggerByType v-wf:WorkItem ;
  v-s:triggerByType v-wf:WorkOrder ;
  v-s:triggerByType v-wf:DecisionForm ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */
var this_uri = document['@'],
    group_uri = veda.Util.getUri(document["v-wf:forProcess"]) || veda.Util.getUri(document["v-wf:forWorkItem"]) || veda.Util.getUri(document["v-wf:onWorkOrder"]) || veda.Util.getUri(document["v-wf:parentWorkOrder"]);

if (!group_uri) { return; }

var membership_uri = 'd:membership_' + this_uri.split(':').join('_') + '_' + group_uri.split(':').join('_');

var membership = {
  '@' : membership_uri,
  'rdf:type'     : veda.Util.newUri('v-s:Membership'),
  'v-s:resource' : veda.Util.newUri(this_uri),
  'v-s:memberOf' : veda.Util.newUri(group_uri),
  'rdfs:comment' : veda.Util.newStr('создано cfg:Event_11'),
  'v-s:canRead'  : veda.Util.newBool(true)
};
put_individual (ticket, membership, _event_id);
//print('cfg:Event_11 process membership', uri);
  """ ;
.

cfg:Event_12
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт включает процесс в группу журнала документа." ;
  rdfs:comment "Скрипт включает процесс в группу журнала документа." ;
  v-s:triggerByType v-s:ProcessStarted ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */
var process_uri = veda.Util.getUri(document['v-wf:onProcess']),
    doc_journal_uri = veda.Util.getUri(document['v-s:onDocument']) + "j";

var membership_uri = 'd:membership_' + process_uri.split(':').join('_') + '_' + doc_journal_uri.split(':').join('_');

var membership = {
  '@' : membership_uri,
  'rdf:type'     : veda.Util.newUri('v-s:Membership'),
  'v-s:memberOf' : veda.Util.newUri(doc_journal_uri),
  'v-s:resource' : veda.Util.newUri(process_uri),
  'rdfs:comment' : veda.Util.newStr('создано cfg:Event_12'),
  'v-s:canRead'  : veda.Util.newBool(true)
};
put_individual (ticket, membership, _event_id);
//print('cfg:Event_12 process membership', uri);
  """ ;
.

cfg:Event_13
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Manually create version" ;
  rdfs:comment "Manually create version" ;
  v-s:triggerByType v-s:ManuallyVersioned ;
  v-s:preventByType v-s:Version;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = previous state of the captured document
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 * super_classes = super classes of the document.
 */

// First class event
if (parent_script_id) {
  // print("Not first class event. Exit.");
  return;
}

// Get actual state
document = get_individual(ticket, document["@"]);
if ( veda.Util.hasValue( document, 'v-s:triggerVersionCreation', {data: true, type: "Boolean"} ) ) {
  delete document['v-s:triggerVersionCreation'];
  veda.Util.create_version(ticket, document, prev_state, user_uri, _event_id);
}
  """ ;
.

cfg:Event_14
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Пусто." ;
  rdfs:comment "Пусто." ;
  v-s:disabled true ;
  v-s:script """
  """ ;
.

cfg:Event_15
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт обработки связей документов" ;
  rdfs:comment "Скрипт обработки связей документов" ;
  v-s:triggerByType v-s:Link ;
  v-s:script """
// First class event
if (parent_script_id) return;

const linkDeleted = veda.Util.hasValue( document, 'v-s:deleted', {data: true, type: 'Boolean'} );
const linkUri = document['@'];
const linkToUri = veda.Util.getUri(document['v-s:to']);
const linkFromUri = veda.Util.getUri(document['v-s:from']);
const linkTo = get_individual(ticket, linkToUri);
const linkFrom = get_individual(ticket, linkFromUri);
const rightsFrom = get_rights(ticket, linkFromUri, user_uri);
const rightsTo = get_rights(ticket, linkToUri, user_uri);
const canReadFrom = veda.Util.hasValue( rightsFrom, 'v-s:canRead', {data: true, type: 'Boolean'} );
const canReadTo = veda.Util.hasValue( rightsTo, 'v-s:canRead', {data: true, type: 'Boolean'} );
const isValidRights = true; // canReadFrom && canReadTo,
let containsThisLink;
const membershipToFromUri = 'd:link_membership_' + linkToUri.split(':').join('_') + '_' + linkFromUri.split(':').join('_');
const membershipFromToUri = 'd:link_membership_' + linkFromUri.split(':').join('_') + '_' + linkToUri.split(':').join('_');
let membershipToFrom;
let membershipFromTo;

remove_individual(ticket, membershipToFromUri, _event_id);
remove_individual(ticket, membershipFromToUri, _event_id);

if (!linkDeleted) {
  const isToMemberOfFrom = veda.Util.hasValue( document, 'v-s:toMemberOfFrom', {data: true, type: 'Boolean'});
  const isFromMemberOfTo = veda.Util.hasValue( document, 'v-s:fromMemberOfTo', {data: true, type: 'Boolean'});
  const isMutual = veda.Util.hasValue( document, 'v-s:mutualMembership', {data: true, type: 'Boolean'});
  if (isValidRights && (isToMemberOfFrom || isMutual)) {
    membershipToFrom = {
      '@': membershipToFromUri,
      'rdf:type': veda.Util.newUri('v-s:Membership'),
      'v-s:memberOf': veda.Util.newUri(linkFromUri),
      'v-s:resource': veda.Util.newUri(linkToUri),
      'rdfs:comment': veda.Util.newStr('создано cfg:Event_15'),
      'v-s:canRead': veda.Util.newBool(true),
    };
    put_individual(ticket, membershipToFrom, _event_id);
  }
  if (isValidRights && (isFromMemberOfTo || isMutual)) {
    membershipFromTo = {
      '@': membershipFromToUri,
      'rdf:type': veda.Util.newUri('v-s:Membership'),
      'v-s:memberOf': veda.Util.newUri(linkToUri),
      'v-s:resource': veda.Util.newUri(linkFromUri),
      'rdfs:comment': veda.Util.newStr('создано cfg:Event_15'),
      'v-s:canRead': veda.Util.newBool(true),
    };
    put_individual(ticket, membershipFromTo, _event_id);
  }
}

if (linkTo) {
  containsThisLink = veda.Util.hasValue(linkTo, 'v-s:hasLink', {data: linkUri, type: 'Uri'});
  if (!containsThisLink && !linkDeleted) {
    linkTo['v-s:hasLink'] = ( linkTo['v-s:hasLink'] || [] ).concat({type: 'Uri', data: linkUri});
    put_individual(ticket, linkTo, _event_id);
  } else if (containsThisLink && linkDeleted) {
    linkTo['v-s:hasLink'] = linkTo['v-s:hasLink'].filter(function (link) {
      return link.data !== linkUri;
    });
    put_individual(ticket, linkTo, _event_id);
  }
}
if (linkFrom) {
  containsThisLink = veda.Util.hasValue(linkFrom, 'v-s:hasLink', {data: linkUri, type: 'Uri'});
  if (!containsThisLink && !linkDeleted) {
    linkFrom['v-s:hasLink'] = ( linkFrom['v-s:hasLink'] || [] ).concat({type: 'Uri', data: linkUri});
    put_individual(ticket, linkFrom, _event_id);
  } else if (containsThisLink && linkDeleted) {
    linkFrom['v-s:hasLink'] = linkFrom['v-s:hasLink'].filter(function (link) {
      return link.data !== linkUri;
    });
    put_individual(ticket, linkFrom, _event_id);
  }
}
  """ ;
.

cfg:Event_15_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт обработки связей документов" ;
  rdfs:comment "Скрипт обработки связей документов" ;
  v-s:triggerByType v-s:LinkObject ;
  v-s:script """

  // First class event
  if (parent_script_id) {
    // print("Not first class event. Exit.");
    return;
  }

  var linkDeleted = veda.Util.hasValue( document, "v-s:deleted", {data: true, type: "Boolean"} ),
      linkUri = document["@"],
      linkToUri = veda.Util.getUri(document["v-s:to"]),
      linkFromUri = veda.Util.getUri(document["v-s:from"]),
      linkTo = get_individual(ticket, linkToUri),
      linkFrom = get_individual(ticket, linkFromUri),
      containsThisLink;
     /* mutualMembership = veda.Util.hasValue( document, "v-s:mutualMembership", {data: true, type: "Boolean"} ),
      membershipToFromUri = "d:link_membership_" + linkToUri.split(":").join("_") + "_" + linkFromUri.split(":").join("_"),
      membershipFromToUri = "d:link_membership_" + linkFromUri.split(":").join("_") + "_" + linkToUri.split(":").join("_"),
      membershipToFrom,
      membershipFromTo;

  membershipToFrom = {
    '@' : membershipToFromUri,
    'rdf:type'     : veda.Util.newUri('v-s:Membership'),
    'v-s:memberOf' : veda.Util.newUri(linkFromUri),
    'v-s:resource' : veda.Util.newUri(linkToUri),
    'rdfs:comment' : veda.Util.newStr('создано cfg:Event_15'),
    'v-s:canRead'  : veda.Util.newBool(true)
  };

  membershipFromTo = {
    '@' : membershipFromToUri,
    'rdf:type'     : veda.Util.newUri('v-s:Membership'),
    'v-s:memberOf' : veda.Util.newUri(linkToUri),
    'v-s:resource' : veda.Util.newUri(linkFromUri),
    'rdfs:comment' : veda.Util.newStr('создано cfg:Event_15'),
    'v-s:canRead'  : veda.Util.newBool(true)
  };
*/
  if (linkTo) {
    containsThisLink = veda.Util.hasValue(linkTo, "v-s:hasLinkObject", { data: linkUri, type: "Uri" });
    if (!containsThisLink && !linkDeleted) {
      linkTo["v-s:hasLinkObject"] = ( linkTo["v-s:hasLinkObject"] || [] ).concat({type: "Uri", data: linkUri});
      put_individual(ticket, linkTo, _event_id);
    } else if (containsThisLink && linkDeleted) {
      linkTo["v-s:hasLinkObject"] = linkTo["v-s:hasLinkObject"].filter(function (link) {
        return link.data !== linkUri;
      });
      put_individual(ticket, linkTo, _event_id);
    }
  }
  if (linkFrom) {
    containsThisLink = veda.Util.hasValue(linkFrom, "v-s:hasLinkObject", { data: linkUri, type: "Uri" });
    if (!containsThisLink && !linkDeleted) {
      linkFrom["v-s:hasLinkObject"] = ( linkFrom["v-s:hasLinkObject"] || [] ).concat({type: "Uri", data: linkUri});
      put_individual(ticket, linkFrom, _event_id);
    } else if (containsThisLink && linkDeleted) {
      linkFrom["v-s:hasLinkObject"] = linkFrom["v-s:hasLinkObject"].filter(function (link) {
        return link.data !== linkUri;
      });
      put_individual(ticket, linkFrom, _event_id);
    }
  }
  /*if (linkDeleted) {
    remove_individual(ticket, membershipToFromUri, _event_id);
    print( "membershipToFrom removed", membershipToFrom["@"] );
  } else {
    put_individual(ticket, membershipToFrom, _event_id);
    print( "membershipToFrom added", JSON.stringify(membershipToFrom) );
  }
  if (mutualMembership) {
    if (linkDeleted) {
      remove_individual(ticket, membershipFromToUri, _event_id);
      print( "membershipFromTo removed", membershipFromTo["@"] );
    } else {
      put_individual(ticket, membershipFromTo, _event_id);
      print( "membershipFromTo added", JSON.stringify(membershipFromTo) );
    }
  }*/
  """ ;
.

cfg:Event_16
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт обработки обратных ссылок" ;
  rdfs:comment "Скрипт обработки обратных ссылок" ;
  v-s:triggerByType v-s:BackwardLink ;
  v-s:preventByType v-s:Version;
  v-s:disallowChangingSource "true"^^xsd:boolean ;
  v-s:script """

  // First class event
  if (parent_script_id) {
    // print("Not first class event. Exit.");
    return;
  }

  var backwardLinkUri = document["@"],
      backwardPropertyUri = veda.Util.getUri(document["v-s:backwardProperty"]),
      backwardTargetUris = veda.Util.getUris(document["v-s:backwardTarget"]),
      backwardReplaceUris = veda.Util.getUris(document["v-s:backwardReplace"]),
      canRead   = document["v-s:canRead"],
      canUpdate = document["v-s:canUpdate"],
      canDelete = document["v-s:canDelete"],
      isDeleted = veda.Util.hasValue(document, "v-s:deleted", { data: true, type: "Boolean" }),
      forceUpdate = veda.Util.hasValue(document, "v-s:backwardForceUpdate", { data: true, type: "Boolean" });

  var prevBackwardTargetUris = prev_state == undefined ? [] : veda.Util.getUris(prev_state["v-s:backwardTarget"]);
  if (prevBackwardTargetUris.length >= backwardTargetUris.length) {
    var changedTargetUris = prevBackwardTargetUris.filter(function(targetUri) {
      return backwardTargetUris.indexOf(targetUri) < 0;
    });
    for (var i = 0; i < changedTargetUris.length; i++) {
      var changedTarget = get_individual(ticket, changedTargetUris[i]);
      var remove_from_backward = {
        "@" : changedTarget["@"]
      };
      remove_from_backward[backwardPropertyUri] = veda.Util.newUri(backwardLinkUri);
      remove_from_individual(ticket, remove_from_backward, _event_id);
    }
  }
  //expected equal backwardPropery and backwardReplaceUris for all backwardTargets
  for (var i = 0; i < backwardTargetUris.length; i++) {
    var backwardTargetUri = backwardTargetUris[i],
        backwardTarget = get_individual(ticket, backwardTargetUri),
        backwardTarget_original = JSON.stringify(backwardTarget);

    if (canRead || canUpdate || canDelete) {
      var membershipUri = "d:backward_membership_" + backwardLinkUri.split(":").join('_') + '_' + backwardTargetUri.split(':').join('_');

      if (isDeleted) {
        remove_individual(ticket, membershipUri, _event_id);
      } else {
        var membership = {
          '@' : membershipUri,
          'rdf:type'     : veda.Util.newUri('v-s:Membership'),
          'v-s:memberOf' : veda.Util.newUri(backwardTargetUri),
          'v-s:resource' : veda.Util.newUri(backwardLinkUri),
          'rdfs:comment' : veda.Util.newStr('создано cfg:Event_16')
        };
        if (canRead) {
          membership["v-s:canRead"] = canRead;
        }
        if (canUpdate) {
          membership["v-s:canUpdate"] = canUpdate;
        }
        if (canDelete) {
          membership["v-s:canDelete"] = canDelete;
        }
        if (isDeleted) {
          membership['v-s:deleted'] = veda.Util.newBool(true);
        }
        put_individual(ticket, membership, _event_id);
      }
    }

    if (veda.Util.hasValue(document, "v-s:mutualMembership", { data: true, type: "Boolean" })) {
      var mutualMembershipUri = "d:backward_m_membership_" + backwardTargetUri.split(':').join('_') + '_' + backwardLinkUri.split(":").join('_');
      if (isDeleted) {
        remove_individual(ticket, mutualMembershipUri, _event_id);
      } else {
        const targetRights = get_rights(ticket, backwardTargetUri, user_uri);
        const canReadTarget = veda.Util.hasValue( targetRights, "v-s:canRead", {data: true, type: "Boolean"} );
        if (canReadTarget) {
          var mMembership = {
            '@' : mutualMembershipUri,
            'rdf:type'     : veda.Util.newUri('v-s:Membership'),
            'v-s:memberOf' : veda.Util.newUri(backwardLinkUri),
            'v-s:resource' : veda.Util.newUri(backwardTargetUri),
            'rdfs:comment' : veda.Util.newStr('создано cfg:Event_16 (mutual membership)'),
            'v-s:canRead' : veda.Util.newBool(true)
          };
          put_individual(ticket, mMembership, _event_id);
        }
      }
    }

    if (!backwardTarget) { continue; }
    if (isDeleted) {
      if (backwardPropertyUri && veda.Util.hasValue(backwardTarget, backwardPropertyUri, { data: backwardLinkUri, type: "Uri" })) {
        // backwardTarget[backwardPropertyUri] = backwardTarget[backwardPropertyUri].filter(function (value) {
        //   return (value.data !== backwardLinkUri);
        // });
        var remove_from_backward = {
          "@" : backwardTarget["@"]
        };
        remove_from_backward[backwardPropertyUri] = veda.Util.newUri(backwardLinkUri);

        print("remove_from_backward: ", veda.Util.toJson(remove_from_backward));
        remove_from_individual(ticket, remove_from_backward, _event_id);
      }
      // for (var property_uri in backwardTarget) {
      //   if (property_uri === "@") { continue; }
      //   backwardTarget[property_uri] = backwardTarget[property_uri].filter(function (value) {
      //     return (value.data !== backwardLinkUri);
      //   });
      // }
    } else if (backwardPropertyUri) {
      var set_to_backward = {
        "@": backwardTarget["@"]
      };
      var isChanged = false;
      var alreadyThere = veda.Util.hasValue(backwardTarget, backwardPropertyUri, { data: backwardLinkUri, type: "Uri" });
      //print( "BL already there =", alreadyThere );
      if ( !alreadyThere ) {
        // backwardTarget[backwardPropertyUri] = backwardTarget[backwardPropertyUri] || [];
        // backwardTarget[backwardPropertyUri].push({type: "Uri", data: backwardLinkUri});
        set_to_backward[backwardPropertyUri] = backwardTarget[backwardPropertyUri] || [];
        set_to_backward[backwardPropertyUri].push({type: "Uri", data: backwardLinkUri});
        isChanged = true;
      }

      backwardReplaceUris.forEach(function (replaceUri) {
        //backwardTarget[replaceUri] = document[replaceUri];
        set_to_backward[replaceUri] = document[replaceUri];
        isChanged = true;
      });
      if (isChanged || forceUpdate) {
        print("set_to_backward: ", veda.Util.toJson(set_to_backward));
        set_in_individual(ticket, set_to_backward, _event_id);
      }
    }
    // if (forceUpdate || JSON.stringify(backwardTarget) !== backwardTarget_original) {
    //   put_individual(ticket, backwardTarget, _event_id);
    //   print( "BL target updated =", JSON.stringify(backwardTarget) );
    // }
  }
  """ ;
.

cfg:Event_Hourly_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в час" ;
  v-s:triggerByUid cfg:hourly ;
  v-s:script """
print("[cfg:Event_Hourly_1] ************************** START **************************");
print("[cfg:Event_Hourly_1] *************************** END ***************************");
  """ ;
.
cfg:Event_Daily_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в день" ;
  v-s:triggerByUid cfg:daily ;
  v-s:script """
print("[cfg:Event_Daily_1] ************************** START **************************");
print("[cfg:Event_Daily_1] *************************** END ***************************");
  """ ;
.
cfg:Event_Daily_Additional
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в день, создан для сохранения очердности" ;
  v-s:triggerByUid cfg:dailyAdditional ;
  v-s:script """
print("[cfg:Event_Daily_Additional] ************************** START **************************");
print("[cfg:Event_Daily_Additional] *************************** END ***************************");
  """ ;
.
cfg:Event_Weekly_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в неделю" ;
  v-s:triggerByUid cfg:weekly ;
  v-s:script """
print("[cfg:Event_Weekly_1] ************************** START **************************");
print("[cfg:Event_Weekly_1] *************************** END ***************************");
  """ ;
.
cfg:Event_Monthly_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в месяц" ;
  v-s:triggerByUid cfg:monthly ;
  v-s:script """
print("[cfg:Event_Monthly_1] ************************** START **************************");
print("[cfg:Event_Monthly_1] *************************** END ***************************");
  """ ;
.
cfg:Event_Yearly_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт запускается раз в год" ;
  v-s:triggerByUid cfg:yearly ;
  v-s:script """
print("[cfg:Event_Yearly_1] ************************** START **************************");
print("[cfg:Event_Yearly_1] *************************** END ***************************");
  """ ;
.
cfg:Event_Notify_Task
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт уведомления о новой задаче" ;
  v-s:triggerByType v-wf:UserTaskForm ;
  v-s:disabled true ;
  v-s:script """
var task_id = document["@"],
    to = veda.Util.getUri(document["v-wf:to"]);
//print("cfg:Event_17", "caught", "task", task_id, "to", to);
  """ ;
.
cfg:Event_Notify_Comment
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт уведомления о новом комментарии" ;
  v-s:triggerByType v-s:Comment ;
  v-s:disabled true ;
  v-s:script """
var comment_id = document["@"],
    comment_target = veda.Util.getUri(document["v-s:backwardTarget"]),
    stakeholder = veda.Util.getUri(comment_target["v-s:author"]);
//print("cfg:Event_18", "caught", "comment", comment_id, "target", comment_target);
  """ ;
.

cfg:Event_Document_Deleting_Restoring
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Скрипт каскадного удаления-восстановления документа и его вложений" ;
  v-s:triggerByType v-s:Deletable ;
  v-s:script """
var types = document["rdf:type"];
//print("***document_deleting");
if (parent_script_id == "cfg:CommentHandler") {
  return;
}
var isDeletingAction = veda.Util.hasValue(document, "v-s:deleted")? document["v-s:deleted"][0].data : undefined;
print("document[v-s:deleted]=", isDeletingAction);
for (var i = 0; i < types.length; i++) {
  var type = types[i];
  print("type.data: ", type.data);
  if (type.data == "v-s:Deletable") continue;
  var querySpec = "'rdf:type'=='v-s:ClassSpecification' && 'v-ui:forClass'==='"+type.data+"'";
  print("  querySpec: ", querySpec);
  var result = query(veda.ticket, querySpec).result;
  for (var specInd = 0; specInd < result.length;specInd++) {
    print("  spec: ", result[specInd]);
    var spec = get_individual(veda.ticket, result[specInd]);
    if (spec["v-s:hasDeletedProperties"] == undefined) continue;
    for (var propInd = 0; propInd < spec["v-s:hasDeletedProperties"].length; propInd++) {
      var property = spec["v-s:hasDeletedProperties"][propInd];
      print("    property.data: ", property.data);
      if (!veda.Util.hasValue(document, property.data)) continue;
      var propValues = document[property.data];
      print("      propValues.length: ", propValues.length);
      for (var valueInd = 0; valueInd < propValues.length; valueInd++) {
        if (isDeletingAction) {
          var add_to_value = {
            "@": propValues[valueInd].data,
            "rdf:type": veda.Util.newUri("v-s:Deletable")
          };
          add_to_individual(veda.ticket, add_to_value);
          print("      add 'deletable' for value: ", propValues[valueInd].data);
          var set_to_value = {
            "@": propValues[valueInd].data,
            "v-s:deleted": veda.Util.newBool(isDeletingAction),
            "v-s:edited": veda.Util.newDate(new Date())
          };
          print("      set 'deleted' & 'edited' for value: ", propValues[valueInd].data);
          if (veda.Util.hasValue(document, 'v-s:archived', { data: true, type: "Boolean" })) {
            set_to_value['v-s:archived'] = veda.Util.newBool(true);
            print("      set 'archived' for value: ", propValues[valueInd].data);
          }
          set_in_individual(veda.ticket, set_to_value);
        } else {
          var set_in_value = {
            "@": propValues[valueInd].data,
            "v-s:deleted": veda.Util.newBool(isDeletingAction)
          };
          print("      set 'deleted:false' in value: ", propValues[valueInd].data);
          set_in_individual(veda.ticket, set_in_value);
        }

      }
    }
  }
}

if (isDeletingAction == false) {
  var remove_from_doc = {
    "@": document["@"],
    "rdf:type": veda.Util.newUri("v-s:Deletable"),
    "v-s:deleted": veda.Util.newBool(isDeletingAction)
  };
  if (veda.Util.hasValue(document, 'v-s:archived', { data: true, type: "Boolean" })) {
    remove_from_doc['v-s:archived'] = veda.Util.newBool(true);
  }
  remove_from_individual(veda.ticket, remove_from_doc);
}
""" ;
.

cfg:Event_Document_Archiving
  rdf:type v-s:Event ;
  rdfs:label "Удаление-архивирование старых документов" ;
  v-s:triggerByUid cfg:weekly ;
  #v-s:disabled true;
  v-s:runAt "V8.LowPriority";
  v-s:script """
print("[cfg:Event_Document_Archiving] ************************** START **************************");

var scriptInfo = get_individual(ticket, "cfg:Event_Document_Archiving_Info");
if (!scriptInfo) {
  var yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  scriptInfo = {
    "@": "cfg:Event_Document_Archiving_Info",
    "rdf:type": veda.Util.newUri('v-s:CronScriptsInfo'),
    "v-s:lastDateOfExecuting":  veda.Util.newDate(yesterday)
  };
}
var msInDay = 86400000;
var lastDate = new Date(scriptInfo['v-s:lastDateOfExecuting'][0].data);
var today = new Date();

var queryString = "'rdf:type'=='v-s:ClassSpecification'";
var result = query(veda.ticket, queryString).result;
print("count spec: ", result.length);
for (var i = 0; i < result.length; i++) {
  print("***********spec: ", result[i]);
  if (result[i]) {
    var spec = get_individual(veda.ticket, result[i]);

    if (!veda.Util.hasValue(spec, "v-s:shelfLife")) {
      print("Skip " + result[i] + ": empty shelfLife");
      continue;
    };
    if (veda.Util.hasValue(spec, "v-s:shelfLife", { data: 9999, type: "Integer" })) {
      print("Skip " + result[i] + ": shelfLife == 9999");
      continue;
    }
    if (!veda.Util.hasValue(spec, "v-ui:forClass")) {
      print("Skip " + result[i] + ": empty hasClass");
      continue;
    };

    var dateProperty = veda.Util.hasValue(spec, "v-s:dateProperties")? spec["v-s:dateProperties"][0].data : "v-s:created";
    var forClass = spec["v-ui:forClass"][0].data;
    var timeLife = new Date(spec["v-s:shelfLife"][0].data);
    var deletedProperties = spec["v-s:hasDeletedProperties"];

    // print("forClass: ", forClass);
    // print("timeLife: ", timeLife);
    // print("deletedProperties: ", veda.Util.toJson(deletedProperties));

    var datePeriod = [new Date(+lastDate-msInDay*(365)*timeLife-1), new Date(+today-msInDay*365*timeLife)];
    var docQueryString = "'rdf:type'==='"+forClass+"' && '"+dateProperty+"'==["+ datePeriod[0].toISOString() +","+ datePeriod[1].toISOString() +"]";
    //print("docQueryString: ", docQueryString);
    var docsForArchive = query(veda.ticket, docQueryString).result;
    print("docsForArchive size: ", docsForArchive.length);

    for (var docInd = 0;docInd < docsForArchive.length; docInd++) {
      print("docUri: ", docsForArchive[docInd]);

      var doc = get_individual(veda.ticket, docsForArchive[docInd]);
      var isDeleted = veda.Util.hasValue(doc, "v-s:deleted")? doc["v-s:deleted"][0].data : false;
      if (isDeleted) {
        print("Skip doc ", doc, " is already deleted");
        continue;
      }
      // var isBuzy = true;
      // var triedCount = 0;
      // while (isBuzy) {
      //   var mainQ = get_individual(veda.ticket, "srv:queue-state-scripts_main0");
      //   var mainQCount;
      //   if (mainQ == undefined) {
      //     print("Break queue handler, srv:queue-state-scripts_main0 is undefined");
      //     break;
      //   }
      //   if ((mainQ["srv:current_count"] && mainQ["srv:current_count"].length > 0) &&
      //       (mainQ["srv:total_count"] && mainQ["srv:total_count"].length > 0 )) {
      //     mainQCount = mainQ["srv:total_count"][0].data - mainQ["srv:current_count"][0].data;
      //   } else {
      //     print("Break queue handler, can't calculate count from srv:queue-state-scripts_main0");
      //     break;
      //   }
      //   print("mainQCount=", mainQCount);
      //   if (mainQCount > 100) {
      //     print("mainQCount > 100, waiting");
      //   } else {
      //     isBuzy = false;
      //   }
      //   var lowQ = get_individual(veda.ticket, "srv:queue-state-scripts_lp0");
      //   var lowQCount;
      //   if (mainQ == undefined) {
      //     print("Break queue handler, srv:queue-state-scripts_lp0 is undefined");
      //     break;
      //   }
      //   if ((lowQ["srv:current_count"] && lowQ["srv:current_count"].length > 0) &&
      //       (lowQ["srv:total_count"] && lowQ["srv:total_count"].length > 0 )) {
      //     lowQCount = lowQ["srv:total_count"][0].data - lowQ["srv:current_count"][0].data;
      //   } else {
      //     print("Break queue handler, can't calculate count from srv:queue-state-scripts_lp0");
      //     break;
      //   };
      //   print("lowQCount=", lowQCount);
      //   if (lowQCount > 100) {
      //     print("lowQCount > 100, waiting");
      //     isBuzy = true;
      //   } else {
      //     isBuzy = false;
      //   };
      //   print("tried count ", ++triedCount);
      // }
      var types = doc["rdf:type"].concat(veda.Util.newUri("v-s:Deletable"));
      var setInDoc = {
        "@": docsForArchive[docInd],
        "v-s:deleted": veda.Util.newBool(true),
        "v-s:archived": veda.Util.newBool(true),
        "rdf:type": types
      };
      set_in_individual(veda.ticket, setInDoc);
      print(docsForArchive[docInd], " archived");
    }
  }
}

scriptInfo['v-s:lastDateOfExecuting'] = veda.Util.newDate(new Date());
put_individual(ticket, scriptInfo, _event_id);

print("[cfg:Event_Document_Archiving] ************************** END **************************");
  """ ;
.

cfg:Event_EstimatedExternalAccount_Delete
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystemAppointment ;
  rdfs:label "Удаление просроченной учетной записи." ;
  v-s:triggerByUid cfg:daily ;
  v-s:runAt "V8.LowPriority";
  v-s:script """
print("[cfg:Event_EstimatedExternalAccount_Delete] ************************** START **************************");

var scriptInfo = get_individual(ticket, 'cfg:Event_EstimatedExternalAccount_Delete_Info');
if (!scriptInfo) {
  var yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  scriptInfo = {
    '@': 'cfg:Event_EstimatedExternalAccount_Delete_Info',
    'rdf:type': veda.Util.newUri('v-s:CronScriptsInfo'),
    'v-s:lastDateOfExecuting':  veda.Util.newDate(yesterday)
  };
}
var lastDate = new Date(scriptInfo['v-s:lastDateOfExecuting'][0].data);
var today = new Date();
var msInDay = 86400000;
var datePeriod = [new Date(+lastDate-msInDay), new Date(+today-msInDay)];
var queryString = "'rdf:type'=='v-s:Account' && 'v-s:origin'=='ExternalUser'";
// && 'v-s:dateTo'==["+ datePeriod[0].toISOString() +","+ datePeriod[1].toISOString() +"]

//print(queryString);
var result = query(ticket, queryString).result;

for (var i=0; i<result.length; i++){
  try {
    var account = get_individual(ticket, result[i]);
    if (veda.Util.hasValue(account, "v-s:dateTo")) {
      var dateTo = new Date(account["v-s:dateTo"][0].data);
      if (today - dateTo < 0) {
        print("Skip ", result[i], ": today < dateTo");
        continue;
      }
    } else {
      print("Skip ", result[i], ": empty dateTo");
      continue;
    }
    var setToAccount = {
      '@': result[i],
      'v-s:deleted': veda.Util.newBool(true)
    };
    set_in_individual(ticket, setToAccount, _event_id);
  } catch (err) {
    print(result[i], err);
    continue;
  };
}
scriptInfo['v-s:lastDateOfExecuting'] = veda.Util.newDate(new Date());
put_individual(ticket, scriptInfo, _event_id);

print("[cfg:Event_EstimatedExternalAccount_Delete] ************************** END **************************");
""" ;
.
